// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj2.command.SubsystemBase;


/**
 *
 */
public class DriveTrain extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private WPI_VictorSPX leftMaster;
private WPI_VictorSPX rightMaster;
private DifferentialDrive differentialDrive;
private WPI_VictorSPX leftFollower;
private WPI_VictorSPX rightFollower;
private Servo linearServo;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private double y;
    private double twist;

    private static double startAngle;
    private static double endAngle;
    private static double currentAngle;
    private static double startTime;
    
    public static final double WPILIB_MIN_SERVO_ANGLE = 0.0; //degrees
    public static final double WPILIB_MAX_SERVO_ANGLE = 360.0; //degrees
    private static final double TIME_TO_SERVO_FULL_EXTENSION = 3.48; //Avg time to move from retract to extend
    private static final double PERCENT_PER_SECOND = 1.00 / TIME_TO_SERVO_FULL_EXTENSION;
    private static final double DEGREES_PER_SECOND = (WPILIB_MAX_SERVO_ANGLE - WPILIB_MIN_SERVO_ANGLE)
    		* PERCENT_PER_SECOND;

    private static final double HOOD_MAX_POSITION = 1.0; //percent servo travel to max hood position
    private static final double HOOD_MIN_POSITION = 0.0; //percent servo travel to min hood position
   
    //SERVO Parameters from https://s3.amazonaws.com/actuonix/Actuonix+L16+Datasheet.pdf
    private static final double MAX_SERVO_PWM = 2.0; //ms
    private static final double MIN_SERVO_PWM = 1.0; //ms
    private static final double SERVO_RANGE = MAX_SERVO_PWM - MIN_SERVO_PWM;
    private static final double CENTER_SERVO_PWM = 1.5; //ms
    private static final double SERVO_DEADBAND = 0.0; //ms - no deadband
    
    // pwm values in ms for the max and min angles of the shooter hood
    private static final double HOOD_MAX_PWM = MIN_SERVO_PWM + (SERVO_RANGE * HOOD_MAX_POSITION);
    private static final double HOOD_MIN_PWM = MIN_SERVO_PWM + (SERVO_RANGE * HOOD_MIN_POSITION);


    /**
    *
    */
    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
leftMaster = new WPI_VictorSPX(0);
 
 

rightMaster = new WPI_VictorSPX(2);
 
 

differentialDrive = new DifferentialDrive(leftMaster, rightMaster);
 addChild("differentialDrive",differentialDrive);
 differentialDrive.setSafetyEnabled(true);
differentialDrive.setExpiration(0.1);
differentialDrive.setMaxOutput(1.0);


leftFollower = new WPI_VictorSPX(1);
 
 

rightFollower = new WPI_VictorSPX(3);
 
 

linearServo = new Servo(0);
 addChild("linearServo", linearServo);
 


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    // see https://docs.wpilib.org/en/stable/docs/yearly-overview/yearly-changelog.html
    rightFollower.setInverted(true);
    rightMaster.setInverted(true);

    // see https://www.chiefdelphi.com/t/not-sure-how-to-code-actuonix-l16-actuator/395887/7
  
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    private double Deadband(double value) {
        /* Upper deadband */
        if (value >= +0.05)
            return value;

        /* Lower deadband */
        if (value <= -0.05)
            return value;

        /* Outside deadband */
        return 0;
    }

    public void driveWithJoystick(Joystick joystickP0) {
        y = joystickP0.getY();
        twist = joystickP0.getTwist();
        y = Deadband(y);
        //tankDrive.arcadeDrive(y,  twist);
        differentialDrive.arcadeDrive(Math.pow(y, 3), Math.pow(twist, 3));
    }


}

